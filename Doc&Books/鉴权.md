# **Web**开发模式

## 服务端渲染

服务端渲染的概念:服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的。

因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据。 代码示例如下 : 

```js
app.get('/index.html', (req, res) => {
  const = user = {name: mike, age: 25};
  // 服务器通过字符串拼接, 动态生成 HTML 内容
  const html = `<h1> Name: ${user.name}, Age: ${user.age} . `
  res.send(html)   // 直接把 html 内容响应给客户端
} 
```



优点:

1. 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 
2. 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。

缺点:

1. 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。
2. 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于 项目高效开发



## 前后端分离

前后端分离的开发模式，依赖于 **Ajax** 技术的广泛应用。后端只负责提供 API 接口，前端使用 Ajax 调用接口

优点:

1. 开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。
2. 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。 
3. 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。

缺点:

不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。

> (解决方案: 利用 Vue、React 等前端框架的 SSR (server side render) 技术能够很好的解决 SEO 问题! )





## 选择 Web 开发模式

不谈业务场景而盲目选择使用何种开发模式都是耍流氓。

- 比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染; 

- 而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。

另外，具体使用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了 首屏服务器端渲染 + 其他页面前后端分离的开发模式。

-----

对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的**身份认证方案** (Node): 

1. 服务端渲染 推荐使用 **Session** **认证机制**
2. 前后端分离 推荐使用 **JWT** 认证机制



HTTP 协议的无状态性，指的是客户端**的每次** **HTTP** **请求都是独立的**，连续多个请求之间没有直接的关系，**服务器不会 主动保留每次** **HTTP** **请求的状态**。







# JWT ( JSON Web Token) 

**Session 认证的局限性**

Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，**需要做很多额外的配置**，才能实现跨域 Session 认证。

注意:
- 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。
- 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。



-----

**JWT 工作原理**

![](http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-07-17-021906.png)



总结:用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。



JWT 通常由三部分组成，分别是 Header(头部)、Payload(有效荷载)、Signature(签名)。

三者之间使用点号 .  分隔，格式如下:

```
Header.Payload.Signature
```

- Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。 
- Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性。



客户端收到服务器返回的 JWT 之后，通常会将它储存在 **localStorage** 或 sessionStorage 中。

此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。

推荐的做法是**把** **JWT** **放在** **HTTP** **请求头的** **Authorization** **字段中**，格式如下:

```
Authorization: `Bear ${Token}`
```





## 使用

安装如下两个 JWT 相关的包

```bash
npm install jsonwebtoken express-jwt
```

- `jsonwebtoken` 用于生成 JWT 字符串
- `express-jwt `用于将 JWT 字符串解析还原成 JSON 对象



```js
const jwt = require('jsonwebtoken')
const expressJWT = require('express-jwt')  // 将 JWT String 还原成 JSON 对象
```



### **定义 Secret 密钥 :** 

为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密的 secret 密钥:

1. 当生成 JWT 字符串的时候，需要使用 secret 密钥 对用户的信息进行加密，最终得到加密好的 JWT 字符串 
2. 当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密

```js
const secretKey = 'ithemi No1 ^_^'   // 就是一个字符串
```



`jsonwebtoken.sign` :  将用户的信息加密成 JWT 字符串，响应给客户端

```js
app.post('./api/login'), function(req, res) {
  // 登录失败..
  // 登录成功 :
  res.send({
    status: 200 ,
    message: "Login Success !",
    // sign 接受 3 个参数 : 用户信息, 加密密钥, 配置对象
    token: jwt.sign({username: info.name}, secretKey, {expireIn: '30s'} )
  })
}  
```



客户端每次在访问那些有权限接口的时候，都需要主动通过**请求头中的** **Authorization** **字段**，将 Token 字符串发送到服务器进行身份认证

此时，服务器可以通过 **express-jwt** 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象:

- `expressJWT({secret: secretKey})`  是用来解析 Token 的中间件
- `.unless({path: [/^\/api\//]})`  用来指定哪些接口不需要访问权限 

```js
app.use(expressJWT({secret: secretKey}).unless({path: [/^\/api\//]}) )
```



### **使用** **req.user** **获取用户信息**

当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 **req.user** 对象，来访问从 JWT 字符串中解析出来的用户信息了，示例代码如下:

```js
// 这是一个有权限的 API 接口
app.get('./admin/getinfo', function(req, res){
  console.log(req.user)
  res.send({
    status: 200 ,
    message: "getIngo Success !",
    data: req.user
  })
})
```



### 捕获解析 JWT 失败后产生的错误

当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行。

可以通过 Express 的错误中间件，捕获这个错误并进行相关的处理，示例代码如下:

```js
app.user(err, req, req, next) => {
  if (err.name === 'UnauthorizedError'){
    return res.send({ status: 401, message: 'Invalid Token !'})
  }
  
  // 兜底的 500 Server 错误
  res.send({ status: 500, message: 'Unknown Error'})
}
```





# 鉴权方式

目前我们常用的鉴权有四种：

1. HTTP Basic Authentication
2. session-cookie
3. Token 验证
4. OAuth(开放授权)



https://juejin.cn/post/6844903602805293069



## 一/ HTTP Basic Authentication

这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐。



## **二/ session-cookie**

第二种这个方式是利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证，由于http请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话(seesion),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建seesion，如果有则已经认证成功了，否则就没有认证。 
 session-cookie认证主要分四步： 

1. 服务器在接受客户端首次访问时在服务器端创建seesion，然后保存seesion(我们可以将seesion保存在内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。        
2. 签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤） 
3. 浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求de 请求头中会带上该域名下的cookie信息
4. 服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。

<img src="http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-06-09-065301.png" width="80%;" />



server.js ( nodejs+express+seesion+redis)

```js
var express = require('express');
var RedisStore = require('connect-redis')(express.session);
var app = express();
var secret  = "wang839305939"
// 设置 Cookie
app.use(express.cookieParser(secret));

// 设置 Session
app.use(express.session({
  store: new RedisStore({
    host: "127.0.0.1",
    port: 6379,
    db: "session_db"
  }),
  secret: secret
}))

app.get("/", function(req, res) {
  var session = req.session;
  session.time= session.time|| 0;
  var n = session.time++;
  res.send('hello, session id:' + session.id + ' count:' + n);
});

app.listen(9080);
```



### **Cookie** 不具有安全性

由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全性。

因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。

**注意:千万不要使用 Cookie 存储重要且隐私的数据!比如用户的身份信息、密码等。**







## **三/ Token 验证**



## **四/ OAuth(开放授权)**

 OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供OAuth认证服务的厂商有支付宝，QQ,微信。 

OAuth协议又有1.0和2.0两个版本。相比较1.0版，2.0版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式 

下面是一张auth2.0的流程图：

![](http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-06-09-065530.png)

从图中我们可以看出，auth2.0流程分为六步（我们就以csdn登陆为例）：



**第一步 :** 

向用户请求授权，现在很多的网站在登陆的时候都有第三方登陆的入口，当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面。

<img src="http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-06-09-065623.png" style="zoom:50%;" />

通过第三方请求授权页面的浏览器地址栏地址可以看出，

```
https://graph.qq.com/oauth2.0/show?which=Login&display=pc&response_type=code&client_id=100270989&redirect_uri=https%3A%2F%2Fpassport.csdn.net%2Faccount%2Flogin%3Foauth_provider%3DQQProvider&state=test
```

这里的地址里面的 % 是浏览器强制编码后的显示我们可以使用decodeURIComponent进行解码，解码后是这样：

```
https://graph.qq.com/oauth2.0/show?which=Login&display=pc
    &response_type=code
    &client_id=100270989
    &redirect_uri=https://passport.csdn.net/account/login
    ?oauth_provider=QQProvider
    &state=test
```



这个url地址我们可以看见 Auth2.0 常见的几个参数： 

- response_type，返回类型 
- client_id，第三方应用id,由授权服务器（qq）在第三方应用提交时颁发给第三方应用。 
- redirect_uri，登陆成功重定向页面 
- oauth_provider，第三方授权提供方        
- state，由第三方应用给出的随机码 



**第二步**

返回用户凭证（code），并返回一个凭证（code），当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址 redirect_uri 的后面

```
https://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&state=XXX
```



**第三步** ──请求授权服务器授权:

经过第二步获取 code 后后面的工作就可以交给后台去处理的，和用户的交互就结束了。接下来我的需要获取 Access Token，我们需要用他来向授权服务器获取用户信息等资源。  第三方应用后台通过第二步的凭证（code）向授权服务器请求 Access Token，这时候需要以下几个信息：

- client_id 标识第三方应用的id，由授权服务器（Github）在第三方应用提交时颁发给第三方应用
- client_secret 第三方应用和授权服务器之间的安全凭证，由授权服务器（Github）在第三方应用提交时颁发给第三方应用
- code 第一步中返回的用户凭证redirect_uri 第一步生成用户凭证后跳转到第二步时的地址
- state 由第三方应用给出的随机码

**第四步**

   授权服务器同意授权后，返回一个资源访问的凭证（Access Token）。

**第五步**

​    第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。

**第六步**

​    资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。



从用户角度来说，第三方授权可以让我们快速的登陆应用，无需进行繁琐的注册,同时不用记住各种账号密码。只需要记住自己常用的几个账号就ok了。 从产品经理的角度来所，这种授权方式提高用户的体验满意度。另一方面可以获取更多的用户。