## Babel

https://zhuanlan.zhihu.com/p/43249121



说到 babel，一连串名词会蹦出来：

- babel-cli
- babel-core
- babel-runtime
- babel-node
- babel-polyfill
- ...

简单来说 babel 把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。

严格来说，babel 也可以转化为更低的规范。但以目前情况来说，es5 规范已经足以覆盖绝大部分浏览器，因此常规来说转到 es5 是一个安全且流行的做法。



执行方式 -- 总共存在三种方式：

1. 使用单体文件 (standalone script)
2. 命令行 (cli)
3. 构建工具的插件 (webpack 的 babel-loader, rollup 的 rollup-plugin-babel)。

其中后面两种比较常见。第二种多见于 package.json 中的 `scripts` 段落中的某条命令；第三种就直接集成到构建工具中。

这三种方式只有入口不同而已，调用的 babel 内核，处理方式都是一样的，所以我们先不纠结入口的问题。



### 运行方式和插件

babel 总共分为三个阶段：解析，转换，生成。

babel 本身不具有任何转化功能，它把转化的功能都分解到一个个 plugin(插件) 里面。因此当我们不配置任何插件时，经过 babel 的代码和输入是相同的, 没有变化。



插件总共分为两种：

**1.语法插件**

>  当我们添加 **语法插件** 之后，在解析这一步就使得 babel 能够解析更多的语法。(顺带一提，babel 内部使用的解析类库叫做 babylon，并非 babel 自行开发)
>
> 举个简单的例子，当我们定义或者调用方法时，最后一个参数之后是不允许增加逗号的，如 `callFoo(param1, param2,)` 就是非法的。如果源码是这种写法，经过 babel 之后就会提示语法错误。
>
> 但最近的 JS 提案中已经允许了这种新的写法(让代码 diff 更加清晰)。为了避免 babel 报错，就需要增加语法插件 `babel-plugin-syntax-trailing-function-commas`

2.**转译插件** 

> 在转换这一步把源码 **转换 并 输出**。这也是我们使用 babel 最本质的需求。
>
> 比如箭头函数 `(a) => a` 就会转化为 `function (a) {return a}`。
>
> 完成这个工作的插件叫做 `babel-plugin-transform-es2015-arrow-functions`。
>
> 同一类语法可能同时存在语法插件版本和转译插件版本。**如果我们使用了转译插件，就不用再使用语法插件了。**

### 配置文件

既然插件是 babel 的根本，那如何使用呢？总共分为 2 个步骤：

1. 将插件的名字增加到配置文件中 (根目录下创建 .babelrc 或者 package.json 的 `babel` 里面，格式相同)
2. 使用 `npm install babel-plugin-xxx` 进行安装



### preset  预配置

>  比如 es2015 是一套规范，包含大概十几二十个转译插件。如果每次要开发者一个个添加并安装，配置文件很长不说，`npm install` 的时间也会很长，更不谈我们可能还要同时使用其他规范呢。

为了解决这个问题，babel 提供了一组插件的集合。因为常用，所以不必重复定义 & 安装





## PostCSS

PostCSS 就是 CSS 界的 Babel。

它们本身只做两件事：

1. 把源代码（或者符合一定条件的扩展语法）解析为一个自带遍历访问、节点操作接口的树；
2. 把语法树输出为代码字符串。

主要的功能，都由插件 plug-in 提供，在第一步完成以后，这棵树以及上面的节点会由一个个插件依次进行处理。插件可以做很多事，比如：

- 识别一些浏览器尚未支持的语法，转换为浏览器支持的（**Autoprefixer**、cssnext）；
- 在不破坏解析的前提下在一定程度上扩展语法，提供*私有*的语法糖；
- 识别出源码中不符合编码规范之处，输出结果来给 linter 显示（Stylelint）；
- 找到并去除冗余代码、将代码压缩为等价且更短的写法（cssnano）；
- ...

和手写 CSS 相比，主要优势很简单：写出更短、更标准、更容易维护的代码。

----

**autoprefixer** 帮我们做好浏览器CSS兼容处理 :

```css
* {
    transition: all .1s;
}`
// 转换过后的代码 index.css
* {
    -webkit-transition: all .1s;
        transition: all .1s;
}`
```



**cssnext** 书写未来的css

```css
:root {
--heading-color: #ff0000;
}

@custom-selector :--headings h1, h2, h3, h4, h5, h6;

:--headings { 
color: var(--heading-color);
}

通过 cssnext，上述代码会被处理成以下内容

h1,
h2,
h3,
h4,
h5,
h6 { 
color: #ff0000;
}
```

Tailwind 也是一个 PostCSS 插件











## ..

## .. 







## 前端技术规划

### 组件库、模块化

首先是组件库，任何一个前端业务团队都会做的事情就是沉淀组件，公共基础组件，业务组件，函数工具库，这对于业界的前端来说是共识。 组件库也就是[轮子库](https://www.zhihu.com/search?q=轮子库&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"105727327"})，是提高团队开发效率的最好方式，同时也是团队的基础沉淀（拿 KPI 的绝佳帮手）

然后是模块化，在几年前，经常会看到一个 js 几千行的情况，但是基于可维护性和重用性的考虑，会把js 拆分成模块，模块化的需求已经很普遍，出现了很多如 `AMD` `CMD` `CommonJs` `UMD` 这些规范，以及 `require.js` `seaJs` `Browserify` `webpack` 这些工具和库来解决这些问题。



## 目前解决这些问题的技术方案

组件化：webComponent、polymer、x-tag、react、jQuery-plugin、angular-directive

模块化：webpack、browserify、require.js、sea.js

开发效率：MVC(Backbone) < Flux(React) < MVVM(Angular.js、vue、[ember.js](https://www.zhihu.com/search?q=ember.js&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"105727327"}))

运行效率：Backbone、React

可维护性：Flux、Redux

作者：陈学家
链接：https://www.zhihu.com/question/39825457/answer/105727327
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。







## 一、前端开发中会有哪些问题需要考虑

讨论这个问题我觉得应该回到问题的本质 -【前端开发会考虑些什么问题】，这些问题即是前端开发过程中的痛点也是难点，了解了这些问题才能知道为什么会有 React 出现，以及 React 如何解决这些问题的。

首先，对于一个前端团队来说，在进行前端技术规划的时候都应该考虑的事情：

1. 组件库、模块化 
2. 开发效率
3. 运行效率
4. 可维护性
5. 体验优化

### 组件库、模块化

首先是组件库，任何一个前端业务团队都会做的事情就是沉淀组件，公共基础组件，业务组件，函数工具库，这对于业界的前端来说是共识。 组件库也就是[轮子库](https://www.zhihu.com/search?q=轮子库&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"105727327"})，是提高团队开发效率的最好方式，同时也是团队的基础沉淀（拿 KPI 的绝佳帮手）

然后是模块化，在几年前，经常会看到一个 js 几千行的情况，但是基于可维护性和重用性的考虑，会把js 拆分成模块，模块化的需求已经很普遍，出现了很多如 `AMD` `CMD` `CommonJs` `UMD` 这些规范，以及 `require.js` `seaJs` `Browserify` `webpack` 这些工具和库来解决这些问题。 

### 开发效率

开发效率是前端团队对业务响应速度的反馈，如果一个业务交给前端团队过后几个月都没有结果那必然会引起上下游的不满， 不管技术做的多棒，选什么框架，最终的目的都是完成业务。 那哪些因素会影响开发效率呢？

\1. 业务代码架构设计 

\2. 可重用模块和组件

第一点是业务代码的架构设计，好的设计能够极大的减少代码量和出 bug 的可能。 第二是拥有大量可重用的模块和组件，能够快速的实现交互



### 运行效率

运行效率是用户体验的关键，对于对效率要求极高的业务场景来说，这可能是选择框架的第一标准 

### 可维护性

前端开发中大多数在做的事情是：

\1. 新业务加功能

\2. 改版 

\3. 解决 bug

特别是在大公司的前端更是体会深刻，可能重来没有做过新业务，都是在维护旧的代码，填坑加埋坑。 如果业务代码设计差，可阅读性差，很难定位 bug。 特别是千奇百怪的 MVC 设计，大控制器，复杂的 Model ，想要定位出哪里出了问题真是一件 eggache 的事情。

### 体验优化

体验已经成了现代化前端开发的必谈之物，所以出现了当页面应用(SPA)，Instant Loading，Application Shell]，Progress webapp 这些名词。

## 二、目前解决这些问题的技术方案

组件化：webComponent、polymer、x-tag、react、jQuery-plugin、angular-directive

模块化：webpack、browserify、require.js、sea.js

开发效率：MVC(Backbone) < Flux(React) < MVVM(Angular.js、vue、[ember.js](https://www.zhihu.com/search?q=ember.js&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"105727327"}))

运行效率：Backbone、React

可维护性：Flux、Redux 

现代化的一些框架几乎都包含组件化的考虑，不过在其他方面各有其优势，关键点是在开发效率和运行效率之间的平衡 

## React 技术栈对上述问题的解决



注意我这里提的是 React 技术栈，并非题主说的 React，个人认为在描述 React 的时候应该是在讲 React 生态体系，那对于上面说的难点痛点在 React 中一一对应的解决方案。

**组件化：**React 天生组件化，这是 React 的核心，除了能够在团队内部积累业务组件以外，也能找到众多开源组件的实现 

**模块化：**基于 webpack 可以使用 Es6 或 CommonJs 的写法实现模块化代码 

**开发效率：**React 的代码基本就是组件的组合，分而治之的方式让代码的可阅读性很高，容易理解。 而且相比于 MVC 几乎是去除了 Controller 的角色，只用关心一个 render 函数，不用关系视图局部的修改。

**运行效率：**React 实现了 Virtual DOM ，相比于 MVVM 框架具有更优的效率 

**可维护性：**React 基于 flux 或 redux 的架构设计，确定性的 store 很容易定位问题，无论是新增业务代码还是查找业务 bug 都不再是难题

**体验：**基于 React 可以很容易的实现 SPA （React-router）

**题外话：**大多数人说 React 技术栈的学习成本太高，其实我想说的是真没有那么难。。。。真的，如果要学 React 但又苦于没有系统的学习资源，那我就打个小广告，最近在维护





南浩 百度 解决方案架构师

一直做Java，去年因为需要全栈独立开发，接触了React，简单说一下。

我之前的基础是这样的：

- 后端是熟悉的；
- js会，但之前用的不多，ES6可以说根本没接触；
- html css局限于皮毛，就是因为很少用，需要查阅文档。



在这个前提下，和大牛简单聊过之后就上路了。前两周一直在翻官方文档，使用官方脚手架做简单的例子，直到后来发现js水平太低。于是花了两周恶补了ES6，于是可以顺利的看懂代码和写页面了。这期间接触了AntDesign，用它做了UI，同时接触到了umijs，用起来觉得挺香。这时候还是在用类组件和复杂的状态管理，接着Hooks就出来，于是学了一下，从此改为函数式组件和Hooks的组合。这时候样式还是用纯css或者less，当然，期间也一直在补这方面的知识漏洞。但随着项目发现，逐渐切换到了React内嵌的样式，感觉这样可以通过大量的变量进行控制，更适合做现在的项目。再往后开始接触TypeScript，后来又发现了umihooks，以及[antd4.0](https://www.zhihu.com/search?q=antd4.0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"1265128343"})等等…反正基本能干活了。最后，用接下来，把js基础夯实了，ES标准学透了，React就不会有太多问题。另外，配合各种轮子一起用(antd umi umihooks真的很香)，工作起来还是很不错的。
